/**
 * 题目描述
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 * @param {number} n 
 */
/**
 * 解法1：
  采用n & (n - 1)的做法，这种做法的可行原因是：能将数字 n 的二进制表示中，最右边的 1 变成 0。
  举个例子，以 5 为例，其二进制是 101:
  101 & 100 => 100
  100 & 011 => 0
  因此，整体思路是：
  n 和 n-1 相与的结果赋给 n
  n 如果为 0，结束；否则回到第 1 步
*/
// 时间复杂度 O(1), 空间复杂度 O(1)。
function NumberOf1(n)
{
    // write code here
    let count = 0;
    while(n){
        n = n & (n-1);
        count++;
    }
    return count;
}
/**
 * 解法2：
    依次判断数字的每一位，统计其中 1 的数量。整体思路如下：
    数字先和 1 相与，结果为 0 说明改位是 1，结果为 1 说明该位是 1
    将 1 左移一位，再和数字相与。这次判断的是倒数第二位是否位 1
    将 1 总共左移 32 次（因为数字底层是 32 位），统计总数即可
    注意：尽量规避让原数字右移动，有符号位的问题，可能会陷入死循环。尽量采取左移而不是右移。
 */
// 时间复杂度 O(1), 空间复杂度 O(1)。
var hammingWeight = function (n) {
    let flag = 1;
    let count = 0;
    let times = 0;
    while (times++ < 32) {
      if (flag & n) {
        count++;
      }
      flag = flag << 1;
    }
    return count;
  };